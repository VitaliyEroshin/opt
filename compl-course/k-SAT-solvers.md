# Решение задачи k-SAT
## Введение
В этом проекте я реализовал и проанализировал алгоритмы для решения **k-SAT** - довольно известной классической $NP$-полной задачи. Здесь будут рассмотрены как детерминированный, так и рандомизированный алгоритмы.

## Некоторые определения и постановка задачи

**Определение.** Литералом будем называть переменную или ее отрицание.

**Определение.** Дизъюнкт (*clause*) - дизъюнкция литералов. Далее я буду работать с дизъюнктом как с множеством литералов. 

**Определение.** Конъюнктивная нормальная форма (КНФ, CNF) формулы $\varphi$ - формула $\psi$, эквивалентная $\varphi$ и представленная в виде *конъюнкции дизъюнктов*. 

**Определение.** k-КНФ - это КНФ, каждый дизъюнкт которой содержит не более k литералов.

**Постановка задачи:** Пусть дана булева формула в k-КНФ. Наша задача - проверить эту формулу на выполнимость, и, если есть выполняющий набор - найти его.

## Алгоритм **Davis–Putnam–Logemann–Loveland** (**[DPLL](https://en.wikipedia.org/wiki/DPLL_algorithm)**) (1962 год)

### Описание и псевдокод
Детерминированный алгоритм, использующий поиск с возвратом. Начнем с псевдокода:

```python
def dpll(cnf):
	# Упрощаем нашу формулу
	eval_set.add(unit_propagate(cnf))
	eval_set.add(pure_literal_assign(cnf))

	# Проверяем, вывелся ли пустой дизъюнкт (т.е. ложь)
	if {} in cnf:
		return UNSAT

	# Проверяем, стала ли наша CNF пустой
	if cnf.is_empty():
		return eval_set

	# Формула упрощена, делаем разветвление
	l = cnf.get_any_literal()

	return dpll(cnf.apply(l)) or dpll(cnf.apply(not l))
```

Рассмотрим используемые процедуры подробнее. Но для этого потребуется сформулировать пару утверждений.

**Утверждение 1.** Если формула содержит дизъюнкт из одного литерала, то значение этого литерала обязательно должно быть истиным.
- *Пусть это не так. Тогда весь дизъюнкт из одного этого литерала не выполняется -> вся КНФ не выполняется

**Утверждение 2.** Если в формуле встречается литерал $l$, но не встречается его отрицание, то всегда выгодно взять в выполняющий набор $l$.
- *Пусть есть выполняющий набор с $\lnot l$. Если мы заменим в этом наборе $\lnot l$ на $l$, то он все еще останется выполняющим набором.*

Процедура `unit_propagate(cnf)` находит все литералы $l$, встречающиеся как дизъюнкт из одного литерала, кладет их в выполняющий набор, и упрощает КНФ, убирая дизъюнкты содержащие $l$, и $\lnot l$ из дизъюнктов с $\lnot l$.  Корректность процедуры следует из утверждения 1. 

Процедура `pure_literal_assign(cnf)` упрощает формулу по утверждению 2.

После того, как мы упростили нашу формулу, можно проверить некоторые критерии, по которым можно установить выполнимость/невыполнимость формулы.

**Критерий 1.** Если КНФ содержит пустой дизъюнкт, то она невыполнима.

**Критерий 2.**  Если КНФ пустая, то она выполнима.

Теперь у нас есть упрощенная формула, и мы не можем ничего сказать про ее выполнимость/невыполнимость. Тут ничего не остается, как делать ветвление. Для этого выберем любой литерал $l$ из формулы, и запустимся рекурсивно от $CNF|_l$ и от $CNF|_{\lnot l}$. 

Если какой-то из запусков нашел выполняющий набор, объединим его с $l$, набором, полученным при упрощении формулы, и вернем. Иначе возвращаем UNSAT.

### Асимптотика
Нетрудно заметить, что алгоритм делает не более $2^N$ разветвлений, где $N$ - количество переменных в нашей формуле. В каждом запуске `dpll` выполняются линейные от количества дизюнктов $M$ процедуры (`unit_propagate`, `pure_literal_assign`, поиск пустого дизъюнкта).

Получаем асимптотику $\mathcal{O}(M \times 2^N)$ 

**Замечание:** k из постановки задачи будем считать константой.

Однако, на практике, из за упрощений DPLL работает гораздо быстрее. Но об этом чуть попозже.

## Алгоритм Paturi-Pudlák-Saks-Zane ([PPSZ](https://cseweb.ucsd.edu/~paturi/myPapers/pubs/PaturiPudlakSaksZane_2005_jacm.pdf)) (2005 год)
Рандомизированный алгоритм, использующий метод резолюций.

Псевдокод:
```python
def ppsz(cnf, s, I):
	bounded_resolve(cnf, s)
	return search(cnf, I)

def bounded_resolve(cnf, s):
	# Находит все дизъюнкты размера не более s,
	# которые можно получить методом резолюций

	# Если есть такие два дизъюнкта x и y, что
	# оба лежат в КНФ и их резольвента имеет размер <= 2,
	# то положим ее в КНФ
	if x, y in cnf and len(resolve(x, y)) <= s:
		cnf.add(resolve(x, y))

def search(cnf, I):
	n = cnf.num_variables()

	for i in 0..I:
		# Генерируем случаюную перестановку
		# и случайный набор присваиваний

		pi = random_permutation(n)
		y = uniform_assignment(n)

		u = modify(cnf.copy(), pi, y)

		# Если выполняющий набор подходит, возвращаем его
		if cnf.sat(u):
			return u

def modify(cnf, pi, y):
	u = array(n)

	# Перебираем переменные в порядке pi
	for i in pi:
		# Если есть дизюнкт из одного литерала,
		# значение литерала определено по утв. 1
		if {var(i)} in cnf:
			u[i] = true

		if {not var(i)} in cnf:
			u[i] = false

		# Иначе присваиваем случайное значение
		u[i] = y[i]

	return u
```

Идея алгоритма в следующем: сначала раздуваем набор дизъюнктов с помощью метода резолюций (`bounded_resolve`), при этом ограничивая размер дизъюнктов некоторой константой $s$.
Затем делаем $I$ итераций поиска (`search`).
На каждой итерации в случайном порядке пытаемся присваивать переменным значения. Если они определены по утверждению 1, то определяем по нему, иначе - случайным образом. (`modify`)

### Асимптотика

Первый этап - раздувание набора дизъюнктов (`bounded_resolve`). Всего количество дизъюнктов можно оценить как $\mathcal{O}(N^s)$ -  в каждом дизъюнкте не более $s$ литералов, все дизъюнкты различны.

В моей реализации получилось находить эти дизъюнкты за $\mathcal{O}(N^{s} \times Poly(N))$, так что `bounded_resolve` можно не брать в асимптотику, вторая часть считается алгоритма считается за экспоненциальное время.

Посчитаем за сколько работает `search`.
Понятно, что `modify` работает за линейное время, однако, он не всегда находит выполняющий набор, даже если он существует.

Пусть $\tau(F)$ - вероятность того, что `modify` найдет выполняющий набор формулы $F$. Тогда итоговая вероятность ошибки (которую мы хотим устремить к 0) будет 
$$(1 - \tau(F))^I \leq exp(-I \tau(F))$$
Тогда можно сформулировать три теоремы:

**Теорема 1.** Пусть $s = \mathcal{o}(\log{n})$, $n$ - количество переменных. Тогда для любой выполнимой 3-КНФ $\tau(F) \geq 2^{−0.521n}$, и при $I = n2^{0.521n}$  алгоритм имеет время работы $\mathcal{O}(2^{0.521n+\mathcal{o}(n)})$ и вероятность ошибки $\mathcal{o}(1)$. 

**Теорема 2.** Пусть $s = \mathcal{o}(\log{n})$, $n$ - количество переменных. Тогда для любой выполнимой 4-КНФ $\tau(F) \geq 2^{−0.625n}$, и при $I = n2^{0.625n}$  алгоритм имеет время работы $\mathcal{O}(2^{0.625n+\mathcal{o}(n)})$ и вероятность ошибки $\mathcal{o}(1)$.

**Теорема 3.** Пусть $s = \mathcal{o}(\log{n})$, $n$ - количество переменных. Тогда для любой выполнимой $k$-КНФ, где $k \geq 5$:
$$\tau(F) \geq 2^{−(1− \frac{\mu_k}{k−1} )n−o(n)} .$$
и при $I = n 2^{−(1− \frac{\mu_k}{k−1} )n−o(n)}$  алгоритм имеет время работы $\mathcal{O}(2^{−(1− \frac{\mu_k}{k−1} )n−o(n)})$ и вероятность ошибки $\mathcal{o}(1)$. Где $\mu_k$:
$$\mu_k = \sum_{j=1}^{\infty} \frac{1}{j(j + \frac{1}{k - 1})}$$

Доказать данные три теоремы предлагается читателю в качестве упражнения.

## Сравнение DPLL и PPSZ на практике

Хоть PPSZ и дает хорошие оценки на асимптотику, протестировать на сложных формулах его не получилось. Первая часть алгоритма, `bounded_resolve`, работает за полиномиальное время. Однако, в моем случае, полином получился настолько большим, что даже при $N = 50$ раздувание происходит довольно долго. Зато потом поиск происходит довольно быстро - алгоритм находит нужный набор за пару итераций.

В случае с DPLL мы не имеем каких то четких оценок на асимптотику. На практике же он показал себя на больших формулах сильно лучше, чем PPSZ.

Для анализа производительности алгоритмов я так же построил графики для 3-КНФ с 20, 50, 75 и 100 переменными. Тесты были взяты с сайта [SATLIB](https://www.cs.ubc.ca/~hoos/SATLIB/benchm.html). Тестирование производилось на чипе Apple M1 Pro (10-cores).

### DPLL
![dpll-performance](https://github.com/VitaliyEroshin/opt/assets/36928556/9c1bcf1d-7aaa-4c58-99b6-aa60d0917030)
На графике изображена зависимость среднего времени работы алгоритма DPLL от количества переменных. График похож на экспоненту, что не удивительно. Во всех тестах DPLL нашел правильный выполняющий набор

### PPSZ
![ppsz-performance](https://github.com/VitaliyEroshin/opt/assets/36928556/070a6cce-e3f1-4954-a3af-a2bed4abd540)

Алгоритм PPSZ из за полиномиальной части алгоритма работает довольно долго даже на 50 переменных, поэтому тесты на 75 и 100 переменных я не проводил. В тестах на 50 переменных я ограничивал по времени работы `bounded_resolve`, поэтому алгоритм находил решение не во всех тестах.

Таблица с долей неудачных запусков PPSZ:
```
   variables  fails
0         20    0.0
1         50    0.3
```


## Источники:
- https://cseweb.ucsd.edu/~paturi/myPapers/pubs/PaturiPudlakSaksZane_2005_jacm.pdf
- https://en.wikipedia.org/wiki/DPLL_algorithm
